#include <graphics.h>
#include <stdlib.h>
#define N 200
#define up 0x4800
#define down 0x5000
#define left 0x4b00
#define right 0x4d00
#define esc 0x011b
#define Y 0x1579
#define n 0x316e
int gamespeed; /* 游戏速度 */
int i, key, color;
int score = 0; /* 游戏分数 */
char cai48H[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0E, 0x00,
    0x1C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x20, 0x00, 0x38, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x78, 0x00, 0x00, 0x01, 0x80, 0x40,
    0x70, 0x00, 0x00, 0x03, 0x80, 0xC0, 0xE0, 0x00,
    0x00, 0x07, 0x80, 0x80, 0xC0, 0x00, 0x00, 0x0E,
    0x11, 0x81, 0xC0, 0x00, 0x00, 0x08, 0x61, 0x01,
    0x80, 0x00, 0x00, 0x00, 0x23, 0x03, 0x04, 0x00,
    0x00, 0x02, 0x02, 0x00, 0x06, 0x00, 0x00, 0x1E,
    0x04, 0x00, 0x0F, 0x00, 0x00, 0x1C, 0x1F, 0x80,
    0x1E, 0x00, 0x00, 0x08, 0x3F, 0x80, 0x3C, 0x00,
    0x00, 0x00, 0xFF, 0x80, 0x38, 0x00, 0x00, 0x03,
    0xFF, 0x80, 0x78, 0x00, 0x00, 0x0F, 0xF8, 0x00,
    0xF0, 0x00, 0x00, 0x7F, 0xF0, 0x00, 0xE0, 0x00,
    0x03, 0xFF, 0xFC, 0x01, 0x80, 0x00, 0x03, 0xC0,
    0xFF, 0x01, 0x03, 0x80, 0x01, 0x01, 0xFF, 0x00,
    0x03, 0x80, 0x00, 0x01, 0x3F, 0x00, 0x07, 0x80,
    0x00, 0x02, 0x11, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x07, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x0E, 0x00, 0x00, 0x08, 0x10, 0x00, 0x1C, 0x00,
    0x00, 0x30, 0x10, 0x00, 0x18, 0x00, 0x00, 0x70,
    0x10, 0x00, 0x30, 0x00, 0x01, 0xE0, 0x10, 0x00,
    0x70, 0x00, 0x03, 0x80, 0x10, 0x00, 0x60, 0x00,
    0x00, 0x00, 0x30, 0x00, 0xE0, 0x00, 0x00, 0x00,
    0xF0, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x70, 0x03,
    0xC0, 0x00, 0x00, 0x00, 0x10, 0x07, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

char she48H[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x07,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0xF8, 0x00, 0x00, 0x02, 0x00, 0x07,
    0x86, 0x00, 0x00, 0x02, 0x00, 0x18, 0x03, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x07, 0x80, 0x00, 0x03,
    0xF0, 0x00, 0x07, 0x80, 0x00, 0x0F, 0xFC, 0x00,
    0x0C, 0x00, 0x00, 0x7E, 0x3F, 0x80, 0x00, 0x00,
    0x01, 0xFE, 0x1F, 0x80, 0x00, 0x00, 0x01, 0xE2,
    0x39, 0x8C, 0x00, 0x00, 0x00, 0xC2, 0x30, 0x08,
    0x00, 0x00, 0x00, 0xC2, 0x60, 0x08, 0x00, 0x00,
    0x00, 0xC3, 0xE0, 0x08, 0x60, 0x00, 0x00, 0x7F,
    0xE0, 0x01, 0xE0, 0x00, 0x00, 0x3F, 0x80, 0x1F,
    0xE0, 0x00, 0x00, 0x1E, 0x00, 0x1F, 0x80, 0x00,
    0x00, 0x1E, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x02,
    0x38, 0x1E, 0x00, 0x00, 0x00, 0x07, 0xFC, 0x1C,
    0x00, 0x20, 0x00, 0x07, 0xFC, 0x18, 0x00, 0x20,
    0x00, 0x1F, 0x0C, 0x10, 0x00, 0x20, 0x00, 0x7C,
    0x04, 0x10, 0x00, 0x60, 0x01, 0xF0, 0x00, 0x10,
    0x00, 0x60, 0x01, 0xE0, 0x00, 0x08, 0x00, 0xF0,
    0x00, 0x80, 0x00, 0x08, 0x03, 0xF0, 0x00, 0x00,
    0x00, 0x07, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07,
    0xFF, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
char tun48H[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x03,
    0xF8, 0x00, 0x40, 0x00, 0x00, 0x00, 0x06, 0x07,
    0xC0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xE0, 0x00,
    0x00, 0x00, 0x07, 0xFF, 0xE0, 0x00, 0x00, 0x00,
    0x0F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x7F, 0xF8,
    0x00, 0x00, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x00,
    0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x1F,
    0xFC, 0x3C, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x0E,
    0x00, 0x00, 0x00, 0x04, 0x70, 0x07, 0x00, 0x00,
    0x00, 0x00, 0x60, 0x03, 0x80, 0x00, 0x00, 0x00,
    0xC0, 0x00, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x00,
    0x30, 0x00, 0x00, 0x01, 0x00, 0x3C, 0x18, 0x00,
    0x00, 0x02, 0x03, 0xFF, 0x0C, 0x00, 0x00, 0x0C,
    0x7F, 0xFF, 0x8E, 0x00, 0x00, 0x18, 0xFF, 0xFF,
    0xC7, 0x80, 0x00, 0x78, 0xFE, 0x07, 0x87, 0xE0,
    0x01, 0xF0, 0x70, 0x07, 0x03, 0xF8, 0x07, 0xE0,
    0x70, 0x0E, 0x03, 0xFE, 0x00, 0x00, 0x38, 0x1E,
    0x01, 0xFE, 0x00, 0x00, 0x3F, 0xFE, 0x00, 0x0C,
    0x00, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFE,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
char dan48H[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x7F, 0xC0, 0x80, 0x00,
    0x00, 0x03, 0xFF, 0x80, 0x40, 0x00, 0x00, 0x01,
    0xF1, 0x80, 0x40, 0x00, 0x00, 0x01, 0x81, 0x80,
    0xE0, 0x00, 0x00, 0x00, 0x01, 0x93, 0xF0, 0x00,
    0x00, 0x00, 0x01, 0xFF, 0xF0, 0x00, 0x00, 0x00,
    0x21, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x21, 0xF8,
    0x00, 0x00, 0x00, 0x00, 0x61, 0xC0, 0x00, 0x00,
    0x00, 0x00, 0x61, 0x80, 0x00, 0x00, 0x00, 0x00,
    0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xFF, 0xC0, 0x00, 0x00,
    0x00, 0x03, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02,
    0x00, 0xFC, 0x00, 0x00, 0x00, 0x04, 0x02, 0x1F,
    0x00, 0x00, 0x00, 0x08, 0x03, 0x01, 0xC0, 0x00,
    0x00, 0x38, 0x03, 0x00, 0x7C, 0x00, 0x00, 0xF8,
    0x07, 0xF8, 0x3F, 0xC0, 0x01, 0xF0, 0x3F, 0xFE,
    0x3F, 0xF8, 0x03, 0xC1, 0xFF, 0x0F, 0x1F, 0xF8,
    0x00, 0x01, 0xE3, 0x0F, 0x0F, 0xF0, 0x00, 0x01,
    0xC3, 0x0E, 0x00, 0x00, 0x00, 0x01, 0x83, 0xFC,
    0x00, 0x00, 0x00, 0x00, 0xC7, 0xF8, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x03,
    0x80, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x1F, 0xF8, 0x20, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0xE0, 0x00, 0x00, 0x07, 0xFF, 0x81, 0xE0, 0x00,
    0x00, 0x07, 0xE0, 0x00, 0xE0, 0x00, 0x00, 0x03,
    0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

char zuo16H[] =
{
    0x18, 0xC0, 0x18, 0xC0, 0x19, 0x80, 0x31, 0xFE,
    0x33, 0xFE, 0x76, 0xC0, 0xF0, 0xFC, 0xB0, 0xFC,
    0x30, 0xC0, 0x30, 0xC0, 0x30, 0xFE, 0x30, 0xFE,
    0x30, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x00, 0x00,
};
char zhe16H[] =
{
    0x03, 0x00, 0x03, 0x0C, 0x1F, 0xCC, 0x1F, 0xD8,
    0x03, 0x30, 0xFF, 0xFE, 0xFF, 0xFE, 0x03, 0x00,
    0x0F, 0xF8, 0x3F, 0xF8, 0xEC, 0x18, 0xCF, 0xF8,
    0x0C, 0x18, 0x0F, 0xF8, 0x0F, 0xF8, 0x00, 0x00,
};


char tian16H[] =
{
    0x00, 0x00, 0x3F, 0xFC, 0x3F, 0xFC, 0x31, 0x8C,
    0x31, 0x8C, 0x31, 0x8C, 0x3F, 0xFC, 0x3F, 0xFC,
    0x31, 0x8C, 0x31, 0x8C, 0x31, 0x8C, 0x3F, 0xFC,
    0x3F, 0xFC, 0x30, 0x0C, 0x00, 0x00, 0x00, 0x00,
};
char xue16H[] =
{
    0x33, 0x18, 0x19, 0x98, 0x08, 0xB0, 0x7F, 0xFC,
    0x7F, 0xFC, 0x60, 0x0C, 0x1F, 0xF0, 0x1F, 0xF0,
    0x00, 0xC0, 0x7F, 0xFC, 0x7F, 0xFC, 0x01, 0x80,
    0x01, 0x80, 0x07, 0x80, 0x03, 0x00, 0x00, 0x00,
};
char ke16H[] =
{
    0x00, 0x00, 0x0C, 0x18, 0xFD, 0x98, 0xF8, 0xD8,
    0x18, 0x58, 0xFE, 0x18, 0xFE, 0x98, 0x18, 0xD8,
    0x3C, 0x58, 0x7E, 0x1E, 0xDB, 0xFE, 0x9B, 0xF8,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
};


struct Food/*定义结构体存储食物的属性*/
{
    int x; /* 食物的坐标 */
    int y;
    int yes; /* 值为0表示屏幕上没有食物，值为1表示屏幕上有食物 */
    int color; /* 食物颜色 */
} food;

struct Snake/*定义结构体存储蛇的属性*/
{
    int x[N]; /* 每一节蛇的坐标 */
    int y[N];
    int color[N];/*存储每一节蛇的颜色*/
    int node; /* 蛇的节数 */
    int direction; /* 蛇移动的方向 */
    int life; /* 蛇的生命，如果为1，蛇死，游戏结束 */
} snake;

void init(void)/*图形驱动*/
{
    int driver = DETECT, mode = 0;
    registerbgidriver(EGAVGA_driver);
    initgraph(&driver, &mode, "");
}

void drawmat(char *mat, int matsize, int x, int y, int color) /*汉字点阵*/
{
    int i, j, k, m;
    m = (matsize - 1) / 8 + 1;
    for(j = 0; j < matsize; j++)
        for(i = 0; i < m; i++)
            for(k = 0; k < 8; k++)
                if(mat[j*m+i]&(0x80 >> k))
                    putpixel(x + i * 8 + k, y + j, color);
}

void showword(void)
{
    /* 调用汉字点阵输出程序，显示标题和作者信息 */
    drawmat(cai48H, 48, 249, -4, 7);
    drawmat(she48H, 48, 329, -4, 7);
    drawmat(tun48H, 48, 409, -4, 7);
    drawmat(dan48H, 48, 489, -4, 7);

    drawmat(cai48H, 48, 250, -5, 4);
    drawmat(she48H, 48, 330, -5, 4);
    drawmat(tun48H, 48, 410, -5, 4);
    drawmat(dan48H, 48, 490, -5, 4);
    /*作者 田学科*/
    drawmat(zuo16H, 16, 515, 465, 7);
    drawmat(zhe16H, 16, 530, 465, 7);

    drawmat(tian16H, 16, 550, 465, 7);
    drawmat(xue16H, 16, 565, 465, 7);
    drawmat(ke16H, 16, 580, 465, 7);
}

void draw(void)/*画出四周的墙*/
{
    if(color == 15)
        color = 0;
    setcolor(++color);
    setlinestyle(SOLID_LINE, 0, 1);

    for(i = 30; i <= 600; i += 10)
    {
        rectangle(i, 40, i + 10, 49);
        rectangle(i, 451, i + 10, 460);
    }
    for(i = 40; i < 450; i += 10)
    {
        rectangle(30, i, 39, i + 10);
        rectangle(601, i, 610, i + 10);
    }
}

void prscore(void)
{
    /* 打印游戏分数 */
    char str[10];
    setfillstyle(SOLID_FILL, YELLOW);
    bar(50, 10, 200, 30);
    setcolor(6);
    settextstyle(0, 0, 2);
    sprintf(str, "score:%d", score);
    outtextxy(55, 15, str);
}

void gameover(void)
{
    cleardevice(); /* 清屏函数 */
    for(i = 0; i < snake.node; i++) /* 画出蛇死时的位置 */
    {
        setcolor(snake.color[i]);
        rectangle(snake.x[i], snake.y[i], snake.x[i] + 10, snake.y[i] + 10);
    }
    prscore(); /* 显示分数 */
    draw();
    showword();
    settextstyle(0, 0, 6);
    setcolor(7);
    outtextxy(103, 203, "GAME OVER");
    setcolor(RED);
    outtextxy(100, 200, "GAME OVER");
}

void gameplay(void)/* 玩游戏的具体过程 */
{
    int flag, flag1;
    randomize();
    prscore();
    gamespeed = 50000;
    food.yes = 0; /* food.yes=0表示屏幕上没有食物 */
    snake.life = 1; /* snake.life=1表示蛇是活着的 */
    snake.direction = 4; /* 表示蛇的初始方向为向右 */
    snake.node = 2; /* 蛇的初始化为两节 */
    snake.color[0] = 2; /*两节蛇头初始化为绿色*/
    snake.color[1] = 2;
    snake.x[0] = 100;
    snake.y[0] = 100;
    snake.x[1] = 110;
    snake.y[1] = 100;
    food.color = random(15) + 1;
    while(1)
    {
        while(1)
        {
            if(food.yes == 0) /* 如果蛇活着 */
            {
                while(1)
                {
                    flag = 1;
                    food.yes = 1;
                    food.x = random(56) * 10 + 40;
                    food.y = random(40) * 10 + 50;
                    for(i = 0; i < snake.node; i++)
                    {
                        if(food.x == snake.x[i] && food.y == snake.y[i])
                            flag = 0;
                    }
                    if(flag) break;
                }
            }
            if(food.yes)
            {
                setcolor(food.color);
                rectangle(food.x, food.y, food.x + 10, food.y + 10);
            }

            for(i = snake.node - 1; i > 0; i--)
            {
                snake.x[i] = snake.x[i-1];
                snake.y[i] = snake.y[i-1];
            }

            switch(snake.direction)
            {
            case 1:
                snake.y[0] -= 10;
                break;
            case 2:
                snake.y[0] += 10;
                break;
            case 3:
                snake.x[0] -= 10;
                break;
            case 4:
                snake.x[0] += 10;
                break;
            }

            for(i = 3; i < snake.node; i++)
            {
                if(snake.x[i] == snake.x[0] && snake.y[i] == snake.y[0])
                {
                    gameover();
                    snake.life = 0;
                    break;
                }
            }

            if(snake.x[0] < 40 || snake.x[0] > 590 || snake.y[0] < 50 || snake.y[0] > 440)
            {
                gameover();
                snake.life = 0;
            }

            if(snake.life == 0)
                break;

            if(snake.x[0] == food.x && snake.y[0] == food.y) /*蛇吃掉食物*/
            {
                setcolor(0);
                rectangle(food.x, food.y, food.x + 10, food.y + 10);
                snake.x[snake.node] = -20;
                snake.y[snake.node] = -20;
                snake.color[snake.node] = food.color;
                snake.node++;
                food.yes = 0;
                food.color = random(15) + 1;
                score += 10;
                prscore();
                if(score % 100 == 0 && score != 0)
                {
                    for(i = 0; i < snake.node; i++) /* 画出蛇 */
                    {
                        setcolor(snake.color[i]);
                        rectangle(snake.x[i], snake.y[i], snake.x[i] + 10, snake.y[i] + 10);
                    }
                    sound(200);
                    delay(50000);
                    delay(50000);
                    delay(50000);
                    delay(50000);
                    delay(50000);
                    delay(50000);
                    nosound();
                    gamespeed -= 5000;
                    draw();
                }
                else
                {
                    sound(500);
                    delay(500);
                    nosound();
                }
            }

            for(i = 0; i < snake.node; i++) /* 画出蛇 */
            {
                setcolor(snake.color[i]);
                rectangle(snake.x[i], snake.y[i], snake.x[i] + 10, snake.y[i] + 10);
            }

            delay(gamespeed);
            delay(gamespeed);
            flag1 = 1;
            setcolor(0);
            rectangle(snake.x[snake.node-1], snake.y[snake.node-1],
                      snake.x[snake.node-1] + 10, snake.y[snake.node-1] + 10);

            if(kbhit() && flag1 == 1) /*如果没按有效键就重新开始循环*/
            {
                flag1 = 0;
                key = bioskey(0);
                if(key == esc)
                    exit(0);
                else if(key == up && snake.direction != 2)
                    snake.direction = 1;
                else if(key == down && snake.direction != 1)
                    snake.direction = 2;
                else if(key == left && snake.direction != 4)
                    snake.direction = 3;
                else if(key == right && snake.direction != 3)
                    snake.direction = 4;
            }
        }
        if(snake.life == 0) /*如果蛇死了就退出循环*/
            break;
    }
}

void main(void)
{
    while(1)
    {
        color = 0;
        init();
        cleardevice();
        showword();
        draw();
        gameplay();
        setcolor(15);
        settextstyle(0, 0, 2);
        outtextxy(200, 400, "CONTINUE(Y/N)?");
        while(1)
        {
            key = bioskey(0);
            if(key == Y || key == n || key == esc)
                break;
        }
        if(key == n || key == esc)
            break;
    }
    closegraph();
} 

<br />本文来自【C语言中文网】：<a href="http://see.xidian.edu.cn/cpp/html/722.html" target="_blank">http://see.xidian.edu.cn/cpp/html/722.html</a>